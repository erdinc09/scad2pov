/*
 * generated by Xtext 2.24.0
 */
package com.karalisoft.serializer;

import com.google.inject.Inject;
import com.karalisoft.scad.Cube;
import com.karalisoft.scad.CubeParams;
import com.karalisoft.scad.Cylinder;
import com.karalisoft.scad.CylinderParams;
import com.karalisoft.scad.Difference;
import com.karalisoft.scad.Function;
import com.karalisoft.scad.Intersection;
import com.karalisoft.scad.Model;
import com.karalisoft.scad.ModuleOrFunctionCall;
import com.karalisoft.scad.Rotate;
import com.karalisoft.scad.ScadPackage;
import com.karalisoft.scad.Scale;
import com.karalisoft.scad.Shape;
import com.karalisoft.scad.Sphere;
import com.karalisoft.scad.SphereParams;
import com.karalisoft.scad.TransformedModuleOrFunctionCall;
import com.karalisoft.scad.TransformedShape;
import com.karalisoft.scad.Translate;
import com.karalisoft.scad.Union;
import com.karalisoft.scad.UseOrInclude;
import com.karalisoft.services.ScadGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class ScadSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ScadGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ScadPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ScadPackage.CUBE:
				sequence_Cube(context, (Cube) semanticObject); 
				return; 
			case ScadPackage.CUBE_PARAMS:
				sequence_CubeParams(context, (CubeParams) semanticObject); 
				return; 
			case ScadPackage.CYLINDER:
				sequence_Cylinder(context, (Cylinder) semanticObject); 
				return; 
			case ScadPackage.CYLINDER_PARAMS:
				sequence_CylinderParams(context, (CylinderParams) semanticObject); 
				return; 
			case ScadPackage.DIFFERENCE:
				sequence_Difference(context, (Difference) semanticObject); 
				return; 
			case ScadPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case ScadPackage.INTERSECTION:
				sequence_Intersection(context, (Intersection) semanticObject); 
				return; 
			case ScadPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ScadPackage.MODULE:
				sequence_Module(context, (com.karalisoft.scad.Module) semanticObject); 
				return; 
			case ScadPackage.MODULE_OR_FUNCTION_CALL:
				sequence_ModuleOrFunctionCall(context, (ModuleOrFunctionCall) semanticObject); 
				return; 
			case ScadPackage.ROTATE:
				sequence_Rotate(context, (Rotate) semanticObject); 
				return; 
			case ScadPackage.SCALE:
				sequence_Scale(context, (Scale) semanticObject); 
				return; 
			case ScadPackage.SHAPE:
				sequence_Shape(context, (Shape) semanticObject); 
				return; 
			case ScadPackage.SPHERE:
				sequence_Sphere(context, (Sphere) semanticObject); 
				return; 
			case ScadPackage.SPHERE_PARAMS:
				sequence_SphereParams(context, (SphereParams) semanticObject); 
				return; 
			case ScadPackage.TRANSFORMED_MODULE_OR_FUNCTION_CALL:
				sequence_TransformedModuleOrFunctionCall(context, (TransformedModuleOrFunctionCall) semanticObject); 
				return; 
			case ScadPackage.TRANSFORMED_SHAPE:
				sequence_TransformedShape(context, (TransformedShape) semanticObject); 
				return; 
			case ScadPackage.TRANSLATE:
				sequence_Translate(context, (Translate) semanticObject); 
				return; 
			case ScadPackage.UNION:
				sequence_Union(context, (Union) semanticObject); 
				return; 
			case ScadPackage.USE_OR_INCLUDE:
				sequence_UseOrInclude(context, (UseOrInclude) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     CubeParams returns CubeParams
	 *
	 * Constraint:
	 *     (size=Double | (x=Double y=Double z=Double) | center='true' | center='false')
	 */
	protected void sequence_CubeParams(ISerializationContext context, CubeParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cube returns Cube
	 *
	 * Constraint:
	 *     (cubeParams+=CubeParams cubeParams+=CubeParams*)?
	 */
	protected void sequence_Cube(ISerializationContext context, Cube semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CylinderParams returns CylinderParams
	 *
	 * Constraint:
	 *     (
	 *         fn=Double | 
	 *         fa=Double | 
	 *         fs=Double | 
	 *         h=Double | 
	 *         r=Double | 
	 *         r1=Double | 
	 *         r2=Double | 
	 *         d=Double | 
	 *         d1=Double | 
	 *         d2=Double | 
	 *         center='true' | 
	 *         center='false'
	 *     )
	 */
	protected void sequence_CylinderParams(ISerializationContext context, CylinderParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cylinder returns Cylinder
	 *
	 * Constraint:
	 *     (cylinderParams+=CylinderParams cylinderParams+=CylinderParams*)?
	 */
	protected void sequence_Cylinder(ISerializationContext context, Cylinder semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Difference returns Difference
	 *
	 * Constraint:
	 *     (shapes+=Shape | shapes+=ModuleOrFunctionCall | shapes+=TransformedModuleOrFunctionCall)*
	 */
	protected void sequence_Difference(ISerializationContext context, Difference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleOrFunction returns Function
	 *     Function returns Function
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.MODULE_OR_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.MODULE_OR_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Intersection returns Intersection
	 *
	 * Constraint:
	 *     (shapes+=Shape | shapes+=ModuleOrFunctionCall | shapes+=TransformedModuleOrFunctionCall)*
	 */
	protected void sequence_Intersection(ISerializationContext context, Intersection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (blocks+=Shape | blocks+=Module | blocks+=Function | blocks+=ModuleOrFunctionCall | blocks+=UseOrInclude)+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ModuleOrFunctionCall returns ModuleOrFunctionCall
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ModuleOrFunctionCall(ISerializationContext context, ModuleOrFunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.MODULE_OR_FUNCTION_CALL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.MODULE_OR_FUNCTION_CALL__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModuleOrFunctionCallAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ModuleOrFunction returns Module
	 *     Module returns Module
	 *
	 * Constraint:
	 *     (name=ID (blocks+=Module | blocks+=Shape | blocks+=Function | blocks+=ModuleOrFunctionCall | blocks+=TransformedModuleOrFunctionCall)*)
	 */
	protected void sequence_Module(ISerializationContext context, com.karalisoft.scad.Module semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transformation returns Rotate
	 *     Rotate returns Rotate
	 *
	 * Constraint:
	 *     (x=Double y=Double z=Double)
	 */
	protected void sequence_Rotate(ISerializationContext context, Rotate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.TRANSFORMATION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.TRANSFORMATION__X));
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.TRANSFORMATION__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.TRANSFORMATION__Y));
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.TRANSFORMATION__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.TRANSFORMATION__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRotateAccess().getXDoubleParserRuleCall_1_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getRotateAccess().getYDoubleParserRuleCall_1_5_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getRotateAccess().getZDoubleParserRuleCall_1_7_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Transformation returns Scale
	 *     Scale returns Scale
	 *
	 * Constraint:
	 *     ((x=Double y=Double z=Double) | scale=Double)
	 */
	protected void sequence_Scale(ISerializationContext context, Scale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Shape returns Shape
	 *
	 * Constraint:
	 *     (
	 *         impl=TransformedShape | 
	 *         impl=Union | 
	 *         impl=Intersection | 
	 *         impl=Difference | 
	 *         impl=Sphere | 
	 *         impl=Cylinder | 
	 *         impl=Cube
	 *     )
	 */
	protected void sequence_Shape(ISerializationContext context, Shape semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SphereParams returns SphereParams
	 *
	 * Constraint:
	 *     (fn=Double | fa=Double | fs=Double | r=Double | d=Double)
	 */
	protected void sequence_SphereParams(ISerializationContext context, SphereParams semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sphere returns Sphere
	 *
	 * Constraint:
	 *     (sphereParams+=SphereParams sphereParams+=SphereParams*)?
	 */
	protected void sequence_Sphere(ISerializationContext context, Sphere semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformedModuleOrFunctionCall returns TransformedModuleOrFunctionCall
	 *
	 * Constraint:
	 *     ((translations+=Translate | translations+=Rotate | translations+=Scale)+ impl+=ModuleOrFunctionCall+)
	 */
	protected void sequence_TransformedModuleOrFunctionCall(ISerializationContext context, TransformedModuleOrFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformedShape returns TransformedShape
	 *
	 * Constraint:
	 *     ((translations+=Translate | translations+=Rotate | translations+=Scale)+ impl+=Shape+)
	 */
	protected void sequence_TransformedShape(ISerializationContext context, TransformedShape semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transformation returns Translate
	 *     Translate returns Translate
	 *
	 * Constraint:
	 *     (x=Double y=Double z=Double)
	 */
	protected void sequence_Translate(ISerializationContext context, Translate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.TRANSFORMATION__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.TRANSFORMATION__X));
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.TRANSFORMATION__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.TRANSFORMATION__Y));
			if (transientValues.isValueTransient(semanticObject, ScadPackage.Literals.TRANSFORMATION__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ScadPackage.Literals.TRANSFORMATION__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTranslateAccess().getXDoubleParserRuleCall_1_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getTranslateAccess().getYDoubleParserRuleCall_1_5_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getTranslateAccess().getZDoubleParserRuleCall_1_7_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Union returns Union
	 *
	 * Constraint:
	 *     (shapes+=Shape | shapes+=ModuleOrFunctionCall | shapes+=TransformedModuleOrFunctionCall)*
	 */
	protected void sequence_Union(ISerializationContext context, Union semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UseOrInclude returns UseOrInclude
	 *
	 * Constraint:
	 *     {UseOrInclude}
	 */
	protected void sequence_UseOrInclude(ISerializationContext context, UseOrInclude semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
